mod error;

use async_trait::async_trait;
use zeroize::Zeroizing;

pub use crate::error::{HsmError, HsmResult};

pub enum HsmKeyAlgorithm {
    AES,
}

pub enum HsmKeypairAlgorithm {
    RSA,
}

pub enum HsmObjectFilter {
    Any,
    AesKey,
    RsaKey,
    RsaPrivateKey,
    RsaPublicKey,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum HsmObjectType {
    Aes,
    RsaPrivate,
    RsaPublic,
}

/// RSA private key value representation
/// All values are in big-endian format
#[derive(Debug)]
pub struct RsaPrivateKeyMaterial {
    pub modulus: Vec<u8>,
    pub public_exponent: Vec<u8>,
    pub private_exponent: Zeroizing<Vec<u8>>,
    pub prime_1: Zeroizing<Vec<u8>>,
    pub prime_2: Zeroizing<Vec<u8>>,
    pub exponent_1: Zeroizing<Vec<u8>>,
    pub exponent_2: Zeroizing<Vec<u8>>,
    pub coefficient: Zeroizing<Vec<u8>>,
}

/// RSA public key value representation
/// All values are in big-endian format
#[derive(Debug)]
pub struct RsaPublicKeyMaterial {
    pub modulus: Vec<u8>,
    pub public_exponent: Vec<u8>,
}

#[derive(Debug)]
pub enum KeyMaterial {
    AesKey(Zeroizing<Vec<u8>>),
    RsaPrivateKey(RsaPrivateKeyMaterial),
    RsaPublicKey(RsaPublicKeyMaterial),
}

#[derive(Debug)]
pub struct HsmObject {
    key_material: KeyMaterial,
    label: String,
}

impl HsmObject {
    pub fn new(key_material: KeyMaterial, label: String) -> Self {
        HsmObject {
            key_material,
            label,
        }
    }

    pub fn key_material(&self) -> &KeyMaterial {
        &self.key_material
    }

    pub fn label(&self) -> &str {
        &self.label
    }
}

#[async_trait(?Send)]
pub trait HSM {
    /// Create the given key in the HSM.
    /// The key ID will be generated by the HSM and returned.
    ///
    /// The key will be exportable from the HSM if the exportable flag is set to true.
    async fn create_key(
        &self,
        slot_id: usize,
        algorithm: HsmKeyAlgorithm,
        key_length_in_bits: usize,
        exportable: bool,
        label: &str,
    ) -> HsmResult<usize>;

    /// Create the given key pair in the HSM.
    /// The private key ID and Public key ID will be generated by the HSM
    /// and returned in that order.
    ///
    /// The key pair will be exportable from the HSM if the exportable flag is set to true.
    async fn create_keypair(
        &self,
        slot_id: usize,
        algorithm: HsmKeypairAlgorithm,
        key_length_in_bits: usize,
        exportable: bool,
        label: &str,
    ) -> HsmResult<(usize, usize)>;

    /// Export objects from the HSN.
    ///
    /// To be exportable, the object must have been created with the exportable flag set to true.
    async fn export(&self, slot_id: usize, object_id: usize) -> HsmResult<Option<HsmObject>>;

    /// Delete an object from the HSM.
    async fn delete(&self, slot_id: usize, object_id: usize) -> HsmResult<()>;

    /// Find objects in the HSM.
    async fn find(&self, slot_id: usize, object_filter: HsmObjectFilter) -> HsmResult<Vec<usize>>;
}
